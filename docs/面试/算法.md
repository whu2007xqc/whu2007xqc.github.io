先看《大话数据结构》，应该比较容易，快速过一遍
再看算法红宝书，https://algs4.cs.princeton.edu/home/
或者算法设计手册


## 一、数组
1. 为节省空间消耗，首先考虑在提供的数组中进行操作，而不是新建其他存储空间。  
2. 尽量在遍历全部元素一次的情况下解决问题。  
3. 矩阵是二维数组的特殊情况。

### 常用技术
1. 双指针  
2. 数组翻转  
全部元素翻转和部分元素翻转可配合使用
4. 环形移动  
将第n个位置的元素向后移动k位，同样n+k位置的元素移动到n+2k位，到达数组尾部之后就重新转回到头部，最终数组中所有的元素都向后移动了k位。  
当数组长度是k的整数倍时，只移动了部分元素，此时需要判断当指针回到初始位置时，移动了的元素的数量是否小于数组长度，如果是则将开始位置向后移一位再次开始环形移动，直到所有元素都被移动过。  
https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2skh7/
4. 位运算
按位与&，按位或|，异或^，取反~，左移<<，右移>>  
5. 哈希表
包括HashMap与HashSet。通过HashMap统计数组元素的出现次数；通过HashSet判断一个元素是否重复出现。  
如果元素的数量是固定的并且较小，那么可以使用数组来代替哈希表。  

### 矩阵
因为矩阵是二维的，所以可以旋转其中的元素；也可以对其进行翻转，包括上下翻转、左右翻转和对角线翻转。  

## 二、字符串
1. 能够通过数学的方式来解决，不要转换为字符串。  
2. 字符串可以看作是字符数组，可以使用数组的解题方法。  

### 常用技术
1. 取模  
十进制数通过与10取模，可以获取最后一位数字，将其除以10之后再次取模，可以获取倒数第二位数字。通过循环此过程，可以逐一从最后一位开始获取数字。  
负数取模得到的余数也是负数。  
2. 状态机  
在处理字符串的字符时，有许多分支情况，要用到大量的if-else，但状态只有固定的几种，此时可以使用有限状态机来让代码更简洁。  
https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnoilh/  
3. KMP  
用于在字符串中匹配字串，复杂度仅为O(m+n)  
先理解PMT https://www.zhihu.com/question/21923021/answer/281346746 ，再看 https://leetcode-cn.com/problems/implement-strstr/solution/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/  
通过在已匹配的子串中，找相同的前缀和后缀，来快速找到下一个可能的匹配的起始点。避免了原字符串每一位都要和目标串从第一位开始匹配。  

## 三、链表
1. 哑节点（dummy node）  
哑节点（dummy node）它的 next 指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。同样对于双向链表，可以在链表头尾各加一个哑节点。  
2. 删除节点  
如果已知要删除的节点，将该节点的属性替换为next节点的属性即可，无需知道head节点以及循环处理。  
3. 对于链表和树这种只知道起始节点的，递归比迭代能节省很多的代码量。  

### 常用技术
1. 双指针  
两个引用分别指向链表中的节点，对于间隔N个节点的情况有用。  
2. 快慢指针  
定位链表中位置的方法，比如想找到链表的中间位置，可以使用两个指针，一个每次往后移动一次，另一个每次往后移动两次。  
也可以判断链表中是否有环，典型的追及问题。  

## 四、树
1. 递归

### 常用技术
1. 三种遍历顺序。前序遍历的顺序是1.当前节点->2.左子树->3.右子树；中序遍历的顺序是1.左子树->2.当前节点->3.右子树；后序遍历的顺序是1.左子树->2.右子树->3.当前节点；  
```java
//前序遍历
public void leftScan(TreeNode root){
    if(root != null){
        System.out.print(root.val);
        leftScan(root.left);
        leftScan(root.right);
    }
}
```
3. 二叉搜索树。当前节点值比左子树的所有节点的值大，比右子树所有节点的值小。  
https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/  

## X、动态规划
### 适用条件
1. 最优化原理（最优子结构性质）  
一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。  
2. 无后效性  
将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。  
3. 子问题的重叠性  
动态规划算法的关键在于解决冗余，即在问题的解决过程中，很多子问题的解被多次使用。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间。  

### 设计步骤
1. 设计状态，表示当前局面
2. 设计状态转移方程，从哪里来或者到哪里去
